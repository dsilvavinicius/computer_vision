#ifndef RANSAC_H
#define RANSAC_H

#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <algorithm>
#include <vector>
#include <map>
#include <utility>
#include <functional>
#include <Eigen/Dense>

#include "Dlt.h"

using namespace std;
using namespace Eigen;

namespace math
{
	using PerSampleIterTable = map< float, int >;
	using RansacIterTable = map< int, PerSampleIterTable >;
	
	/** Suppose a linear system defined by restrictions generated by a sample with s elements in a large set S. The RANSAC
	 * algorithm ensures that the solution of the system defined by the final sample with s elements will have big
	 * concordance with all elements in S. In other words, the final solution of the system will have a small number of
	 * outliers in S. */
	template < typename T >
	class Ransac
	{
	public:
		/** Initializes RANSAC.
		 * @param set is the set of elements from which the algorithm will acquire the samples.
		 * @param evaluator is a function to evaluate the linear system for a sample in S, returning the system solution.
		 * @param nElementsPerSample is the number of elements in a sample. The sample defines the linear system.
		 * @param epsilon is the initial probability of outliers in samples.
		 */
		Ransac( vector< T > set, int nElementsPerSample, double epsilon );
		
		/** Computes the result of the linear system.
		 * @param evaluator evaluates the vector of samples and returns the system solution.
		 * @param scorer scores the solution computed by evaluator, returning a new epsilon.
		 */
		MatrixXd compute();
		
		/** Generates iteration table. */
		static RansacIterTable genIterTable();
		
		/** Table for some precomputed values of number of iterations for Ransac. The key is a pair with first member being
		 * the number of elements in the sample and the second member being the percentage of outliers in the set. */
		//static RansacIterTable m_iterTable;
		
	private:
		/** Calculates the iteration table key, given the number of elements in sample and probability of having outliers. */
		//static float calcIterTableKey( int numElements, float outlierProb );
		
		/** Gets the number of iteration, give the number of elements in sample and the probability of having outliers. */
		static double getIterNumber( int numElements, float outlierProb );
		
		/** The samples. */
		vector< T > m_set;
		
		/** Probability of getting outliers. */
		double m_epsilon;
		
		/** Number of samples per iteration. */
		int m_nElementsPerSample;
		
		/** Estimated number of iterations to guarantee a sample without outliers. */
		double m_nIter;
	};
	
	//template< typename T>
	//RansacIterTable Ransac< T >::m_iterTable = Ransac< T >::genIterTable();
	
	/*template< typename T>
	float Ransac< T >::calcIterTableKey( int numElements, float outlierProb )
	{
		return numElements * outlierProb;
	}*/
	
	template< typename T >
	double Ransac< T >::getIterNumber( int numElements, float outlierProb )
	{
		//return Ransac< T >::m_iterTable[ numElements ].lower_bound( outlierProb )->second;
		double result = log( 1. - 0.99 ) / log( 1. - pow( 1. - outlierProb, 4. ) );
		//cout << "Iter number calculation: " << result << endl << "Epsilon: " << outlierProb << endl << endl;
		return result;
	}
	
	template< typename T>
	Ransac< T >::Ransac( vector< T > set, int nElementsPerSample, double epsilon ) :
		m_set( set ),
		m_nElementsPerSample( nElementsPerSample ),
		m_epsilon( epsilon )
	{
		//m_epsilon = epsilon > 0.5 ? 0.5 : epsilon;
		
		m_nIter = getIterNumber( m_nElementsPerSample, m_epsilon );
		srand( time( NULL ) );
	}
	
	template< typename T>
	MatrixXd Ransac< T >::compute()
	{
		MatrixXd bestSol;
		int maxInliers = 0;
		for( double iter = 0; iter < m_nIter; ++iter ) 
		{
			//cout << "Current epsilon: " << m_epsilon << endl << "Current max iters: " << m_nIter << endl
			//	 << "Current iter: " << iter << endl << endl;
			
			vector< T > sample;
			
			for( int i = 0; i < m_nElementsPerSample; ++i )
			{
				sample.push_back( m_set[ rand() % m_set.size() ] );
			}
			
			Dlt dlt( sample );
			MatrixXd systemSol = dlt.solve();
			
			int currInliers = dlt.scoreSolution( m_set );
			double newEpsilon = 1 - ((double) currInliers /  m_set.size() );
			//cout << "Iter score: " << newEpsilon << endl << endl;
			
			if( newEpsilon < m_epsilon ) // With interation calculation goes to infinity.
			{
				m_epsilon = newEpsilon;
				m_nIter = getIterNumber( m_nElementsPerSample, m_epsilon );
			
				if( currInliers > maxInliers )
				{
					maxInliers = currInliers;
					bestSol = systemSol;
				}
			}
		}
		
		return bestSol;
	}
	
	template< typename T>
	RansacIterTable Ransac< T >::genIterTable()
	{
		PerSampleIterTable iterTable3;
		iterTable3[ 0.05f ] = 3;
		iterTable3[ 0.10f ] = 4;
		iterTable3[ 0.20f ] = 7;
		iterTable3[ 0.25f ] = 9;
		iterTable3[ 0.30f ] = 11;
		iterTable3[ 0.40f ] = 19;
		iterTable3[ 0.50f ] = 50;
		
		PerSampleIterTable iterTable4;
		iterTable4[ 0.05f ] = 3;
		iterTable4[ 0.10f ] = 5;
		iterTable4[ 0.20f ] = 9;
		iterTable4[ 0.25f ] = 13;
		iterTable4[ 0.30f ] = 17;
		iterTable4[ 0.40f ] = 34;
		iterTable4[ 0.50f ] = 72;
		
		PerSampleIterTable iterTable5;
		iterTable5[ 0.05f ] = 4;
		iterTable5[ 0.10f ] = 6;
		iterTable5[ 0.20f ] = 12;
		iterTable5[ 0.25f ] = 17;
		iterTable5[ 0.30f ] = 26;
		iterTable5[ 0.40f ] = 57;
		iterTable5[ 0.50f ] = 146;
		
		PerSampleIterTable iterTable6;
		iterTable6[ 0.05f ] = 4;
		iterTable6[ 0.10f ] = 7;
		iterTable6[ 0.20f ] = 16;
		iterTable6[ 0.25f ] = 24;
		iterTable6[ 0.30f ] = 37;
		iterTable6[ 0.40f ] = 97;
		iterTable6[ 0.50f ] = 293;
		
		PerSampleIterTable iterTable7;
		iterTable7[ 0.05f ] = 4;
		iterTable7[ 0.10f ] = 8;
		iterTable7[ 0.20f ] = 20;
		iterTable7[ 0.25f ] = 33;
		iterTable7[ 0.30f ] = 54;
		iterTable7[ 0.40f ] = 163;
		iterTable7[ 0.50f ] = 588;
		
		PerSampleIterTable iterTable8;
		iterTable8[ 0.05f ] = 5;
		iterTable8[ 0.10f ] = 9;
		iterTable8[ 0.20f ] = 26;
		iterTable8[ 0.25f ] = 44;
		iterTable8[ 0.30f ] = 78;
		iterTable8[ 0.40f ] = 272;
		iterTable8[ 0.50f ] = 1177;
		
		RansacIterTable table;
		table[ 3 ] = iterTable3;
		table[ 4 ] = iterTable4;
		table[ 5 ] = iterTable5;
		table[ 6 ] = iterTable6;
		table[ 7 ] = iterTable7;
		table[ 8 ] = iterTable8;
		
		return table;
	}
}

#endif