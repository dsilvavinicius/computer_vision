#ifndef RANSAC_H
#define RANSAC_H

#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <algorithm>
#include <vector>
#include <map>
#include <utility>
#include <functional>
#include <Eigen/Dense>

#include "Dlt.h"

using namespace std;
using namespace Eigen;

namespace math
{
	using PerSampleIterTable = map< float, int >;
	using RansacIterTable = map< int, PerSampleIterTable >;
	
	/** Suppose a linear system defined by restrictions generated by a sample with s elements in a large set S. The RANSAC
	 * algorithm ensures that the solution of the system defined by the final sample with s elements will have big
	 * concordance with all elements in S. In other words, the final solution of the system will have a small number of
	 * outliers in S. */
	template < typename T >
	class Ransac
	{
	public:
		/** Initializes RANSAC.
		 * @param set is the set of elements from which the algorithm will acquire the samples.
		 * @param evaluator is a function to evaluate the linear system for a sample in S, returning the system solution.
		 * @param nElementsPerSample is the number of elements in a sample. The sample defines the linear system.
		 * @param epsilon is the initial probability of outliers in samples.
		 */
		Ransac( vector< T > set, int nElementsPerSample, double epsilon );
		
		/** Computes the result of the linear system.
		 * @param evaluator evaluates the vector of samples and returns the system solution.
		 * @param scorer scores the solution computed by evaluator, returning a new epsilon.
		 */
		MatrixXd compute();
		
		/** Table for some precomputed values of number of iterations for Ransac. The key is a pair with first member being
		 * the number of elements in the sample and the second member being the percentage of outliers in the set. */
		//static RansacIterTable m_iterTable;
		
	private:
		/** Calculates the iteration table key, given the number of elements in sample and probability of having outliers. */
		//static float calcIterTableKey( int numElements, float outlierProb );
		
		/** Gets the number of iteration, give the number of elements in sample and the probability of having outliers. */
		static double getIterNumber( int numElements, float outlierProb );
		
		/** The samples. */
		vector< T > m_set;
		
		/** Probability of getting outliers. */
		double m_epsilon;
		
		/** Number of samples per iteration. */
		int m_nElementsPerSample;
		
		/** Estimated number of iterations to guarantee a sample without outliers. */
		double m_nIter;
	};
	
	//template< typename T>
	//RansacIterTable Ransac< T >::m_iterTable = Ransac< T >::genIterTable();
	
	/*template< typename T>
	float Ransac< T >::calcIterTableKey( int numElements, float outlierProb )
	{
		return numElements * outlierProb;
	}*/
	
	template< typename T >
	double Ransac< T >::getIterNumber( int numElements, float outlierProb )
	{
		//return Ransac< T >::m_iterTable[ numElements ].lower_bound( outlierProb )->second;
		double result = log( 1. - 0.99 ) / log( 1. - pow( 1. - outlierProb, 4. ) );
		//cout << "Iter number calculation: " << result << endl << "Epsilon: " << outlierProb << endl << endl;
		return result;
	}
	
	template< typename T>
	Ransac< T >::Ransac( vector< T > set, int nElementsPerSample, double epsilon ) :
		m_set( set ),
		m_nElementsPerSample( nElementsPerSample ),
		m_epsilon( epsilon )
	{
		//m_epsilon = epsilon > 0.5 ? 0.5 : epsilon;
		
		m_nIter = getIterNumber( m_nElementsPerSample, m_epsilon );
		srand( time( NULL ) );
	}
	
	template< typename T>
	MatrixXd Ransac< T >::compute()
	{
		MatrixXd bestSol;
		for( double iter = 0; iter < m_nIter; ++iter ) 
		{
			//cout << "Current epsilon: " << m_epsilon << endl << "Current max iters: " << m_nIter << endl
			//	 << "Current iter: " << iter << endl << endl;
			
			vector< T > sample;
			
			for( int i = 0; i < m_nElementsPerSample; ++i )
			{
				sample.push_back( m_set[ rand() % m_set.size() ] );
			}
			
			Dlt dlt( sample );
			MatrixXd systemSol = dlt.solve();
			
			int currInliers = dlt.scoreSolution( m_set );
			double newEpsilon = 1 - ((double) currInliers /  m_set.size() );
			//cout << "Iter score: " << newEpsilon << endl << endl;
			
			if( newEpsilon < m_epsilon ) // With interation calculation goes to infinity.
			{
				cout << "Better result. Inliers: " << currInliers << " of " << m_set.size() << ", Prev epsilon: "
					 << m_epsilon << ", new Epsilon: " << newEpsilon << ", Prev iter: " << m_nIter;
				
				m_epsilon = newEpsilon;
				m_nIter = getIterNumber( m_nElementsPerSample, m_epsilon );
				
				cout << ", New Iter: " << m_nIter << ", Current Iter: " << iter << endl << endl;
				bestSol = systemSol;
			}
		}
		
		return bestSol;
	}
}

#endif