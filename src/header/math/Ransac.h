#ifndef RANSAC_H
#define RANSAC_H

#include <vector>
#include <map>
#include <utility>
#include <functional>
#include <Eigen/Dense>

using namespace std;
using namespace Eigen;

namespace math
{
	using RansacIterTableKey = pair< int, float >;
	using RansacIterTable = map< RansacIterTableKey, int >;
	
	/** Suppose a linear system defined by restrictions generated by a sample with s elements in a large set S. The RANSAC
	 * algorithm ensures that the solution of the system defined by the final sample with s elements will have big
	 * concordance with all elements in S. In other words, the final solution of the system will have a small number of
	 * outliers in S. */
	template < typename T >
	class Ransac
	{
	public:
		/** Initializes RANSAC.
		 * @param set is the set of elements from which the algorithm will acquire the samples.
		 * @param evaluator is a function to evaluate the linear system for a sample in S, returning the new epsilon for
		 * the algorithm's current iteration and the system solution.
		 * @param nElementsPerSample is the number of elements in a sample. The sample defines the linear system.
		 * @param epsilon is the initial probability of outliers in samples.
		 */
		Ransac( vector< T > set, VectorXd ( evaluator )( vector< T >, double& ), int nElementsPerSample,
				double epsilon = 1 );
		
		/** Computes the result of the linear system. */
		VectorXd compute();
		
		/** Generates iteration table. */
		static RansacIterTable genIterTable();
		
		/** Table for some precomputed values of number of iterations for Ransac. The key is a pair with first member being
		 * the number of elements in the sample and the second member being the percentage of outliers in the set. */
		static RansacIterTable m_iterTable;
		
	private:
		/** The samples. */
		vector< T > m_set;
		
		/** Function to define and evaluate the linear system.
		 * @returns the new epsilon for current algorithm's iteration.
		 */
		function< double ( vector< T > ) > m_evaluator;
		
		/** Probability of getting outliers. */
		double m_epsilon;
		
		/** Number of samples per iteration. */
		int m_nElementsPerSample;
		
		/** Estimated number of iterations to guarantee a sample without outliers. */
		int m_nIter;
	};
}

#endif