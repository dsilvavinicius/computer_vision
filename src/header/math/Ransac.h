#ifndef RANSAC_H
#define RANSAC_H

#include <stdlib.h>
#include <time.h>
#include <algorithm>
#include <vector>
#include <map>
#include <utility>
#include <functional>
#include <Eigen/Dense>

#include "Dlt.h"

using namespace std;
using namespace Eigen;

namespace math
{
	using RansacIterTableKey = pair< int, float >;
	using RansacIterTable = map< RansacIterTableKey, int >;
	
	/** Suppose a linear system defined by restrictions generated by a sample with s elements in a large set S. The RANSAC
	 * algorithm ensures that the solution of the system defined by the final sample with s elements will have big
	 * concordance with all elements in S. In other words, the final solution of the system will have a small number of
	 * outliers in S. */
	template < typename T >
	class Ransac
	{
	public:
		/** Initializes RANSAC.
		 * @param set is the set of elements from which the algorithm will acquire the samples.
		 * @param evaluator is a function to evaluate the linear system for a sample in S, returning the system solution.
		 * @param nElementsPerSample is the number of elements in a sample. The sample defines the linear system.
		 * @param epsilon is the initial probability of outliers in samples.
		 */
		Ransac( vector< T > set, int nElementsPerSample, double epsilon = 1 );
		
		/** Computes the result of the linear system.
		 * @param evaluator evaluates the vector of samples and returns the system solution.
		 * @param scorer scores the solution computed by evaluator, returning a new epsilon.
		 */
		MatrixXd compute();
		
		/** Generates iteration table. */
		static RansacIterTable genIterTable();
		
		/** Table for some precomputed values of number of iterations for Ransac. The key is a pair with first member being
		 * the number of elements in the sample and the second member being the percentage of outliers in the set. */
		static RansacIterTable m_iterTable;
		
	private:
		/** The samples. */
		vector< T > m_set;
		
		/** Probability of getting outliers. */
		double m_epsilon;
		
		/** Number of samples per iteration. */
		int m_nElementsPerSample;
		
		/** Estimated number of iterations to guarantee a sample without outliers. */
		int m_nIter;
	};
	
	template< typename T>
	RansacIterTable Ransac< T >::m_iterTable = Ransac< T >::genIterTable();
	
	template< typename T>
	Ransac< T >::Ransac( vector< T > set, int nElementsPerSample, double epsilon ) :
		m_set( set ),
		m_nElementsPerSample( nElementsPerSample ),
		m_epsilon( epsilon )
	{
		m_nIter = Ransac::m_iterTable[ RansacIterTableKey( m_nElementsPerSample, m_epsilon ) ];
	}
	
	template< typename T>
	MatrixXd Ransac< T >::compute()
	{
		MatrixXd bestSol;
		for( int iter = 0; iter < m_nIter; ++iter ) 
		{
			vector< T > sample;
			srand( time( NULL ) );
			
			for( int i = 0; i < m_nElementsPerSample; ++i )
			{
				sample.push_back( m_set[rand() % m_set.size()] );
			}
			
			Dlt dlt(sample);
			MatrixXd systemSol = dlt.solve();
			double newEpsilon = dlt.scoreSolution( m_set );
			
			if( newEpsilon < m_epsilon )
			{
				// Round epsilon to 2 decimal places.
				m_epsilon = round( newEpsilon * 100 ) / 100;
				m_nIter = Ransac::m_iterTable[ RansacIterTableKey( m_nElementsPerSample, m_epsilon ) ];
				bestSol = systemSol;
			}
		}
		
		return bestSol;
	}
	
	template< typename T>
	RansacIterTable Ransac< T >::genIterTable()
	{
		RansacIterTable table;
		
		table[ RansacIterTableKey( 3, 0.05f ) ] = 3;
		table[ RansacIterTableKey( 3, 0.10f ) ] = 4;
		table[ RansacIterTableKey( 3, 0.20f ) ] = 7;
		table[ RansacIterTableKey( 3, 0.25f ) ] = 9;
		table[ RansacIterTableKey( 3, 0.30f ) ] = 11;
		table[ RansacIterTableKey( 3, 0.40f ) ] = 19;
		table[ RansacIterTableKey( 3, 0.50f ) ] = 50;
		
		table[ RansacIterTableKey( 4, 0.05f ) ] = 3;
		table[ RansacIterTableKey( 4, 0.10f ) ] = 5;
		table[ RansacIterTableKey( 4, 0.20f ) ] = 9;
		table[ RansacIterTableKey( 4, 0.25f ) ] = 13;
		table[ RansacIterTableKey( 4, 0.30f ) ] = 17;
		table[ RansacIterTableKey( 4, 0.40f ) ] = 34;
		table[ RansacIterTableKey( 4, 0.50f ) ] = 72;
		
		table[ RansacIterTableKey( 5, 0.05f ) ] = 4;
		table[ RansacIterTableKey( 5, 0.10f ) ] = 6;
		table[ RansacIterTableKey( 5, 0.20f ) ] = 12;
		table[ RansacIterTableKey( 5, 0.25f ) ] = 17;
		table[ RansacIterTableKey( 5, 0.30f ) ] = 26;
		table[ RansacIterTableKey( 5, 0.40f ) ] = 57;
		table[ RansacIterTableKey( 5, 0.50f ) ] = 146;
		
		table[ RansacIterTableKey( 6, 0.05f ) ] = 4;
		table[ RansacIterTableKey( 6, 0.10f ) ] = 7;
		table[ RansacIterTableKey( 6, 0.20f ) ] = 16;
		table[ RansacIterTableKey( 6, 0.25f ) ] = 24;
		table[ RansacIterTableKey( 6, 0.30f ) ] = 37;
		table[ RansacIterTableKey( 6, 0.40f ) ] = 97;
		table[ RansacIterTableKey( 6, 0.50f ) ] = 293;
		
		table[ RansacIterTableKey( 7, 0.05f ) ] = 4;
		table[ RansacIterTableKey( 7, 0.10f ) ] = 8;
		table[ RansacIterTableKey( 7, 0.20f ) ] = 20;
		table[ RansacIterTableKey( 7, 0.25f ) ] = 33;
		table[ RansacIterTableKey( 7, 0.30f ) ] = 54;
		table[ RansacIterTableKey( 7, 0.40f ) ] = 163;
		table[ RansacIterTableKey( 7, 0.50f ) ] = 588;
		
		table[ RansacIterTableKey( 8, 0.05f ) ] = 5;
		table[ RansacIterTableKey( 8, 0.10f ) ] = 9;
		table[ RansacIterTableKey( 8, 0.20f ) ] = 26;
		table[ RansacIterTableKey( 8, 0.25f ) ] = 44;
		table[ RansacIterTableKey( 8, 0.30f ) ] = 78;
		table[ RansacIterTableKey( 8, 0.40f ) ] = 272;
		table[ RansacIterTableKey( 8, 0.50f ) ] = 1177;
		
		return table;
	}
}

#endif